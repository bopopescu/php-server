#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright: (c) 2013, Balazs Pocze <banyek@gawker.com>
# Certain parts are taken from Mark Theunissen's mysqldb module
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type


ANSIBLE_METADATA = {'metadata_version': '1.1',
                    'status': ['preview'],
                    'supported_by': 'community'}


DOCUMENTATION = r'''
---
module: mysql_replication
short_description: Manage MySQL replication
description:
    - Manages MySQL server replication, subordinate, main status get and change main host.
version_added: "1.3"
author:
- Balazs Pocze (@banyek)
options:
    mode:
        description:
            - module operating mode. Could be getsubordinate (SHOW SLAVE STATUS), getmain (SHOW MASTER STATUS), changemain (CHANGE MASTER TO), startsubordinate
              (START SLAVE), stopsubordinate (STOP SLAVE), resetsubordinate (RESET SLAVE), resetsubordinateall (RESET SLAVE ALL)
        type: str
        choices:
            - getsubordinate
            - getmain
            - changemain
            - stopsubordinate
            - startsubordinate
            - resetsubordinate
            - resetsubordinateall
        default: getsubordinate
    main_host:
        description:
            - Same as mysql variable.
        type: str
    main_user:
        description:
            - Same as mysql variable.
        type: str
    main_password:
        description:
            - Same as mysql variable.
        type: str
    main_port:
        description:
            - Same as mysql variable.
        type: int
    main_connect_retry:
        description:
            - Same as mysql variable.
        type: int
    main_log_file:
        description:
            - Same as mysql variable.
        type: str
    main_log_pos:
        description:
            - Same as mysql variable.
        type: int
    relay_log_file:
        description:
            - Same as mysql variable.
        type: str
    relay_log_pos:
        description:
            - Same as mysql variable.
        type: int
    main_ssl:
        description:
            - Same as mysql variable.
        type: bool
    main_ssl_ca:
        description:
            - Same as mysql variable.
        type: str
    main_ssl_capath:
        description:
            - Same as mysql variable.
        type: str
    main_ssl_cert:
        description:
            - Same as mysql variable.
        type: str
    main_ssl_key:
        description:
            - Same as mysql variable.
        type: str
    main_ssl_cipher:
        description:
            - Same as mysql variable.
        type: str
    main_auto_position:
        description:
            - Whether the host uses GTID based replication or not.
        type: bool
        version_added: "2.0"
extends_documentation_fragment:
- mysql
'''

EXAMPLES = r'''
# Stop mysql subordinate thread
- mysql_replication:
    mode: stopsubordinate

# Get main binlog file name and binlog position
- mysql_replication:
    mode: getmain

# Change main to main server 192.0.2.1 and use binary log 'mysql-bin.000009' with position 4578
- mysql_replication:
    mode: changemain
    main_host: 192.0.2.1
    main_log_file: mysql-bin.000009
    main_log_pos: 4578

# Check subordinate status using port 3308
- mysql_replication:
    mode: getsubordinate
    login_host: ansible.example.com
    login_port: 3308
'''

import os
import warnings

from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.mysql import mysql_connect, mysql_driver, mysql_driver_fail_msg
from ansible.module_utils._text import to_native


def get_main_status(cursor):
    cursor.execute("SHOW MASTER STATUS")
    mainstatus = cursor.fetchone()
    return mainstatus


def get_subordinate_status(cursor):
    cursor.execute("SHOW SLAVE STATUS")
    subordinatestatus = cursor.fetchone()
    return subordinatestatus


def stop_subordinate(cursor):
    try:
        cursor.execute("STOP SLAVE")
        stopped = True
    except Exception:
        stopped = False
    return stopped


def reset_subordinate(cursor):
    try:
        cursor.execute("RESET SLAVE")
        reset = True
    except Exception:
        reset = False
    return reset


def reset_subordinate_all(cursor):
    try:
        cursor.execute("RESET SLAVE ALL")
        reset = True
    except Exception:
        reset = False
    return reset


def start_subordinate(cursor):
    try:
        cursor.execute("START SLAVE")
        started = True
    except Exception:
        started = False
    return started


def changemain(cursor, chm, chm_params):
    sql_param = ",".join(chm)
    query = 'CHANGE MASTER TO %s' % sql_param
    cursor.execute(query, chm_params)


def main():
    module = AnsibleModule(
        argument_spec=dict(
            login_user=dict(type='str'),
            login_password=dict(type='str', no_log=True),
            login_host=dict(type='str', default='localhost'),
            login_port=dict(type='int', default=3306),
            login_unix_socket=dict(type='str'),
            mode=dict(type='str', default='getsubordinate', choices=[
                'getmain', 'getsubordinate', 'changemain', 'stopsubordinate', 'startsubordinate', 'resetsubordinate', 'resetsubordinateall']),
            main_auto_position=dict(type='bool', default=False),
            main_host=dict(type='str'),
            main_user=dict(type='str'),
            main_password=dict(type='str', no_log=True),
            main_port=dict(type='int'),
            main_connect_retry=dict(type='int'),
            main_log_file=dict(type='str'),
            main_log_pos=dict(type='int'),
            relay_log_file=dict(type='str'),
            relay_log_pos=dict(type='int'),
            main_ssl=dict(type='bool', default=False),
            main_ssl_ca=dict(type='str'),
            main_ssl_capath=dict(type='str'),
            main_ssl_cert=dict(type='str'),
            main_ssl_key=dict(type='str'),
            main_ssl_cipher=dict(type='str'),
            connect_timeout=dict(type='int', default=30),
            config_file=dict(type='path', default='~/.my.cnf'),
            client_cert=dict(type='path', aliases=['ssl_cert']),
            client_key=dict(type='path', aliases=['ssl_key']),
            ca_cert=dict(type='path', aliases=['ssl_ca']),
        )
    )
    mode = module.params["mode"]
    main_host = module.params["main_host"]
    main_user = module.params["main_user"]
    main_password = module.params["main_password"]
    main_port = module.params["main_port"]
    main_connect_retry = module.params["main_connect_retry"]
    main_log_file = module.params["main_log_file"]
    main_log_pos = module.params["main_log_pos"]
    relay_log_file = module.params["relay_log_file"]
    relay_log_pos = module.params["relay_log_pos"]
    main_ssl = module.params["main_ssl"]
    main_ssl_ca = module.params["main_ssl_ca"]
    main_ssl_capath = module.params["main_ssl_capath"]
    main_ssl_cert = module.params["main_ssl_cert"]
    main_ssl_key = module.params["main_ssl_key"]
    main_ssl_cipher = module.params["main_ssl_cipher"]
    main_auto_position = module.params["main_auto_position"]
    ssl_cert = module.params["client_cert"]
    ssl_key = module.params["client_key"]
    ssl_ca = module.params["ca_cert"]
    connect_timeout = module.params['connect_timeout']
    config_file = module.params['config_file']

    if mysql_driver is None:
        module.fail_json(msg=mysql_driver_fail_msg)
    else:
        warnings.filterwarnings('error', category=mysql_driver.Warning)

    login_password = module.params["login_password"]
    login_user = module.params["login_user"]

    try:
        cursor = mysql_connect(module, login_user, login_password, config_file, ssl_cert, ssl_key, ssl_ca, None, 'mysql_driver.cursors.DictCursor',
                               connect_timeout=connect_timeout)
    except Exception as e:
        if os.path.exists(config_file):
            module.fail_json(msg="unable to connect to database, check login_user and login_password are correct or %s has the credentials. "
                                 "Exception message: %s" % (config_file, to_native(e)))
        else:
            module.fail_json(msg="unable to find %s. Exception message: %s" % (config_file, to_native(e)))

    if mode in "getmain":
        status = get_main_status(cursor)
        if not isinstance(status, dict):
            status = dict(Is_Main=False, msg="Server is not configured as mysql main")
        else:
            status['Is_Main'] = True
        module.exit_json(**status)

    elif mode in "getsubordinate":
        status = get_subordinate_status(cursor)
        if not isinstance(status, dict):
            status = dict(Is_Subordinate=False, msg="Server is not configured as mysql subordinate")
        else:
            status['Is_Subordinate'] = True
        module.exit_json(**status)

    elif mode in "changemain":
        chm = []
        chm_params = {}
        result = {}
        if main_host:
            chm.append("MASTER_HOST=%(main_host)s")
            chm_params['main_host'] = main_host
        if main_user:
            chm.append("MASTER_USER=%(main_user)s")
            chm_params['main_user'] = main_user
        if main_password:
            chm.append("MASTER_PASSWORD=%(main_password)s")
            chm_params['main_password'] = main_password
        if main_port is not None:
            chm.append("MASTER_PORT=%(main_port)s")
            chm_params['main_port'] = main_port
        if main_connect_retry is not None:
            chm.append("MASTER_CONNECT_RETRY=%(main_connect_retry)s")
            chm_params['main_connect_retry'] = main_connect_retry
        if main_log_file:
            chm.append("MASTER_LOG_FILE=%(main_log_file)s")
            chm_params['main_log_file'] = main_log_file
        if main_log_pos is not None:
            chm.append("MASTER_LOG_POS=%(main_log_pos)s")
            chm_params['main_log_pos'] = main_log_pos
        if relay_log_file:
            chm.append("RELAY_LOG_FILE=%(relay_log_file)s")
            chm_params['relay_log_file'] = relay_log_file
        if relay_log_pos is not None:
            chm.append("RELAY_LOG_POS=%(relay_log_pos)s")
            chm_params['relay_log_pos'] = relay_log_pos
        if main_ssl:
            chm.append("MASTER_SSL=1")
        if main_ssl_ca:
            chm.append("MASTER_SSL_CA=%(main_ssl_ca)s")
            chm_params['main_ssl_ca'] = main_ssl_ca
        if main_ssl_capath:
            chm.append("MASTER_SSL_CAPATH=%(main_ssl_capath)s")
            chm_params['main_ssl_capath'] = main_ssl_capath
        if main_ssl_cert:
            chm.append("MASTER_SSL_CERT=%(main_ssl_cert)s")
            chm_params['main_ssl_cert'] = main_ssl_cert
        if main_ssl_key:
            chm.append("MASTER_SSL_KEY=%(main_ssl_key)s")
            chm_params['main_ssl_key'] = main_ssl_key
        if main_ssl_cipher:
            chm.append("MASTER_SSL_CIPHER=%(main_ssl_cipher)s")
            chm_params['main_ssl_cipher'] = main_ssl_cipher
        if main_auto_position:
            chm.append("MASTER_AUTO_POSITION = 1")
        try:
            changemain(cursor, chm, chm_params)
        except mysql_driver.Warning as e:
            result['warning'] = to_native(e)
        except Exception as e:
            module.fail_json(msg='%s. Query == CHANGE MASTER TO %s' % (to_native(e), chm))
        result['changed'] = True
        module.exit_json(**result)
    elif mode in "startsubordinate":
        started = start_subordinate(cursor)
        if started is True:
            module.exit_json(msg="Subordinate started ", changed=True)
        else:
            module.exit_json(msg="Subordinate already started (Or cannot be started)", changed=False)
    elif mode in "stopsubordinate":
        stopped = stop_subordinate(cursor)
        if stopped is True:
            module.exit_json(msg="Subordinate stopped", changed=True)
        else:
            module.exit_json(msg="Subordinate already stopped", changed=False)
    elif mode in "resetsubordinate":
        reset = reset_subordinate(cursor)
        if reset is True:
            module.exit_json(msg="Subordinate reset", changed=True)
        else:
            module.exit_json(msg="Subordinate already reset", changed=False)
    elif mode in "resetsubordinateall":
        reset = reset_subordinate_all(cursor)
        if reset is True:
            module.exit_json(msg="Subordinate reset", changed=True)
        else:
            module.exit_json(msg="Subordinate already reset", changed=False)

    warnings.simplefilter("ignore")


if __name__ == '__main__':
    main()
